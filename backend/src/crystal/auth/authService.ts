// backend/src/crystal/auth/authService.ts

import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import { config } from "../../config/config";
import { logger } from "../../utils/logger";
import {
  User,
  Team,
  SignupRequest,
  LoginRequest,
  AuthResponse,
  JwtPayload,
  UserRole,
  ChangePasswordRequest,
} from "./authTypes";

export class AuthService {
  // Hash password
  static async hashPassword(password: string): Promise<string> {
    try {
      const saltRounds = config.bcryptSaltRounds;
      const hashedPassword = await bcrypt.hash(password, saltRounds);
      return hashedPassword;
    } catch (error) {
      logger.error("Error hashing password:", error);
      throw new Error("Password hashing failed");
    }
  }

  // Compare password
  static async comparePassword(
    plainPassword: string,
    hashedPassword: string
  ): Promise<boolean> {
    try {
      const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
      return isMatch;
    } catch (error) {
      logger.error("Error comparing password:", error);
      throw new Error("Password comparison failed");
    }
  }

  // Generate JWT token
  static generateJwtToken(user: User, team?: Team): string {
    try {
      const payload: JwtPayload = {
        sub: user.id,
        email: user.email,
        role: user.role,
        teamId: team?.id,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60, // 7 days
      };

      // FIXED CODE
      const token = jwt.sign(payload, config.jwtSecret as string);

      return token;
    } catch (error) {
      logger.error("Error generating JWT token:", error);
      throw new Error("Token generation failed");
    }
  }

  // Verify JWT token
  static verifyJwtToken(token: string): JwtPayload {
    try {
      const decoded = jwt.verify(
        token,
        config.jwtSecret as string
      ) as JwtPayload;
      return decoded;
    } catch (error) {
      logger.error("Error verifying JWT token:", error);
      throw new Error("Invalid or expired token");
    }
  }

  // Generate email verification token
  static generateEmailVerificationToken(email: string): string {
    try {
      const payload = {
        email,
        type: "email_verification",
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // 24 hours
      };

      const token = jwt.sign(payload, config.jwtSecret as string);
      return token;
    } catch (error) {
      logger.error("Error generating email verification token:", error);
      throw new Error("Email verification token generation failed");
    }
  }

  // Generate password reset token
  static generatePasswordResetToken(email: string): string {
    try {
      const payload = {
        email,
        type: "password_reset",
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 60 * 60, // 1 hour
      };

      const token = jwt.sign(payload, config.jwtSecret as string);
      return token;
    } catch (error) {
      logger.error("Error generating password reset token:", error);
      throw new Error("Password reset token generation failed");
    }
  }

  // Verify special token (email verification or password reset)
  static verifySpecialToken(
    token: string,
    expectedType: string
  ): { email: string } {
    try {
      const decoded = jwt.verify(token, config.jwtSecret as string) as any;

      if (decoded.type !== expectedType) {
        throw new Error("Invalid token type");
      }

      return { email: decoded.email };
    } catch (error) {
      logger.error("Error verifying special token:", error);
      throw new Error("Invalid or expired token");
    }
  }

  // Create user and team (signup)
  static async createUserAndTeam(
    signupData: SignupRequest
  ): Promise<{ user: User; team?: Team }> {
    try {
      // Hash password
      const hashedPassword = await this.hashPassword(signupData.password);

      // TODO: Replace with actual database operations
      // This is a placeholder - will be replaced with Prisma operations
      const newUser: User = {
        id: "generated-user-id", // Will be generated by database
        email: signupData.email,
        password: hashedPassword,
        name: signupData.name,
        role: "owner" as UserRole,
        isEmailVerified: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      let newTeam: Team | undefined;

      if (signupData.teamName) {
        newTeam = {
          id: "generated-team-id", // Will be generated by database
          name: signupData.teamName,
          ownerId: newUser.id,
          plan: "free",
          createdAt: new Date(),
          updatedAt: new Date(),
        };

        newUser.teamId = newTeam.id;
      }

      logger.info(`User created successfully: ${newUser.email}`);

      // FIXED CODE
      const result: { user: User; team?: Team } = {
        user: newUser,
        ...(newTeam && { team: newTeam }),
      };
      return result;
    } catch (error) {
      logger.error("Error creating user and team:", error);
      throw new Error("User creation failed");
    }
  }

  // Authenticate user (login)
  static async authenticateUser(loginData: LoginRequest): Promise<User> {
    try {
      // TODO: Replace with actual database query
      // This is a placeholder - will be replaced with Prisma operations
      const user = await this.findUserByEmail(loginData.email);

      if (!user) {
        throw new Error("User not found");
      }

      const isPasswordValid = await this.comparePassword(
        loginData.password,
        user.password
      );

      if (!isPasswordValid) {
        throw new Error("Invalid password");
      }

      logger.info(`User authenticated successfully: ${user.email}`);

      return user;
    } catch (error) {
      logger.error("Error authenticating user:", error);
      throw error;
    }
  }

  // Find user by email (placeholder)
  static async findUserByEmail(email: string): Promise<User | null> {
    // TODO: Replace with actual Prisma database query
    // This is a placeholder
    logger.info(`Looking up user by email: ${email}`);
    return null;
  }

  // Find user by ID (placeholder)
  static async findUserById(id: string): Promise<User | null> {
    // TODO: Replace with actual Prisma database query
    // This is a placeholder
    logger.info(`Looking up user by ID: ${id}`);
    return null;
  }

  // Update user password
  static async updateUserPassword(
    userId: string,
    newPassword: string
  ): Promise<void> {
    try {
      const hashedPassword = await this.hashPassword(newPassword);

      // TODO: Replace with actual Prisma database update
      // This is a placeholder
      logger.info(`Password updated for user: ${userId}`);
    } catch (error) {
      logger.error("Error updating user password:", error);
      throw new Error("Password update failed");
    }
  }

  // Mark email as verified
  static async markEmailAsVerified(email: string): Promise<void> {
    try {
      // TODO: Replace with actual Prisma database update
      // This is a placeholder
      logger.info(`Email verified for user: ${email}`);
    } catch (error) {
      logger.error("Error marking email as verified:", error);
      throw new Error("Email verification failed");
    }
  }

  // Create auth response
  static createAuthResponse(user: User, team?: Team): AuthResponse {
    const token = this.generateJwtToken(user, team);

    // Remove password from user object
    const { password, ...userWithoutPassword } = user;

    return {
      user: userWithoutPassword,
      team: team as Team, // Ensure 'team' is always of type Team (not undefined)
      accessToken: token,
    };
  }

  // Add this to AuthService class in authService.ts
  static async findTeamById(teamId: string): Promise<Team | null> {
    // TODO: Replace with actual Prisma database query
    // This is a placeholder
    logger.info(`Looking up team by ID: ${teamId}`);
    return null;
  }
}
